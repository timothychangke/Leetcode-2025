Add two numbers

1. Edge Case: Addition of two numbers of difference lengths, negative numbers
2. Idea: Initialse a carry and pointers to traverse the numbers. Sum there values and mod by ten to append to the res
3. Pseudo Code:
    1. Initialise a carry and two pointers at the ends of each list. 
    2. If not null, sum their values together, let the sum = sum % 10 and the carry = sum // 10
    3. Increment the points if not null
    4. Repeat until pointers and carry are invalid
4. Time Complexity: O(n)
5. Space Complexity: O(1)
6. Learnings: Create a dummy node for res and return res.next, add the remainder of the two numbers if any, sum and carry can be derived with % and //


Intersection of two linked list

1. Edge Case: 
2. Idea: Traverse each string once and count its length. Increment the longer strings pointer to make up for the difference then traverse each node together. One of these nodes will be the Intersection
3. Pseudo Code:
    1. Traverse each string and count its length
    2. Increment the longer string by the difference then compare each node to check if they are the same
    3. Return the Intersection
4. Time Complexity: O(n)
5. Space Complexity: O(1) 
6. Learnings: Find intersection from the difference in lengths, use the a is b operator to check identical => is operator checks if two objects are identical in memory and not in equality


Linked list cycle

1. Edge Case: No cycle
2. Idea: Initialise a fast and slow pointer, when they meet is where the fast pointer overlaps the slow pointer. Initialise another pointer at the start and where they meet will be the start of the cycle
3. Pseudo Code:
    1. Initialise a fast and a slow pointer where at each loop the fast pointer moves two nodes while the slow pointer moves One
    2. Stop the loop when they intersection
    3. Initialise another pointer at teh start point and find the intersection between this new point and where the previous point intersection
    4. Return this intersection as the start of the cycle
4. Time Complexity: O(n)
5. Space Complexity: O(1)
6. Learnings: The floyds turtle and hare algorithm


Merge Two Sorted list 

1. Edge Case: Empty or null lists, lists of different lengths
2. Idea: Initialise two pointers at the start of each list, check the smaller and append to res
3. Pseudo Code:
    1. Initialise two pointers at the start of each list
    2. Initialise a res node where res.next is the node. Later return res.next
    3. Whichever of the two node values are smaller, append to res
    4. Loop until one of the nodes are invalid, the break out of the loop and append the last bit of the still valid list
4. Time Complexity: O(n)
5. Space Complexity: O(1)
6. Learnings: Dont forget about the last bit of the linked list. Initialise a cur to traverse the result while returning dummy.next

Reverse Linked list

1. Edge Case: Empty or singly noded list
2. Idea: have a previous and a curr, do a swap at each iteration
3. Pseudo Code:
    1. Set prev to null and curr to the head of the node
    2. While curr is valid, set cur.next to prev, prev to cur and cur to cur.next
4. Time Complexity: O(n)
5. Space Complexity: O(1)
6. Learnings: One liner reversal

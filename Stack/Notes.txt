Baseball Game

1. Edge Case: Invalid inputs, negative numbers, 
2. Pseudo Code: 
    1. Initialise a stack
    2. Iterate through the operations string and check for the various characters
        - If character is 'C': pop the top of the stack
        - If the character is 'D': pop, multiply by two and append back the top of the stack
        - If the character is '+': pop the two most recent elements from the stack, add them up and append them back into the stack
        - Else, append that character into the stack
3. Time Complexity: O(n)
4. Space Complexity: O(n)


Implement Queue using a stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have two stacks, stack 1 and stack 2. When you append things append it to stack 1. When you pop things, first check if stack 2 is empty, if it is not, then pop from stack 2. Else, move over all the items from stack 1 to stack 2, this inverts
the order of all the elements
3. Pseudo Code: 
    1. Initialise two stacks
    2. For appends, add it to the first stack
    3. For pops, 
        - If stack 2 is not empty, pop from stack 2
        - Else, while stack 1 is not empty, pop then append all elements into stack 2, then pop the very last element
    4. For peeks, do the pop operation just that you return and not pop the last element
4. Time Complexity: O(1) for appends and O(1) also for pops. Each element is popped only once 
5. Space Complexity: O(n)


Implement Queue using stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have a queue where you append to the end of the queue, but when it is time to pop, you pop and append n - 1 elements such that the lru element is now at the top of the queue
3. Pseudo Code:
    1. Initialise a queue
    2. For appends, add to the back of the queue
    3. For pops, pop and reappend n - 1 elements in the queue such that the most recently added element is at the top of the queue
    4. For peek, just return the last element in the queue
4. Time Complexity: O(1) for appends and O(n) for pops
5. Space Complexity: O(n)


Valid Parenthesis

1. Edge Case: Parenthesis pattern is contains characters that are not brackets
2. Idea: Initialise a stack mapping closing brackets with their openning brackets. Have a stack to store open brackets. When met with a closing bracket, pop from the stack and check if its the corresponding open bracket. If invalid, return false
3. Pseudo Code:
    1. Initialise a hash map with the closing brackets as the keys and the openning brackets as the values. 
    2. Iterate through the string
        - If the element is a not in the dictionary (an openning bracket), append it to the stack
        - Else, pop the stack and check if the current element (a closing bracket) correspondes to the openning bracket, if not return false
    3. Return True but only if the stack is empty
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Check for any elements left in the stack as well to ensure validity


Largest Rectangle in Histogram

1. Edge Case: all increasing or all decreasing height arrays
2. Idea: Declare a monoatomically increasing stack as the height of the rectangle only stops growing if there is a rectangle smaller than it. 
3. Pseudo Code:
    1. Append a zero at the end of the height array to clear all the rectangles still left in the stack
    2. Initialise a monoatomically increasing stack that pops elements if they are more than the current one (append their index). After the pop, calculate the area generated by that rectangle and append to res if its greater
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Initalising of the 0 at the end to clear all the remaining rectangles as well as appending a -1 to the stack so that the first rectangles area can be calculated


Maximum Frequency stack

1. Edge Case: 
2. Idea: Initialise a default dict that stores the frequencies of the elements and the dictionary that stores the counts. Also initialise a max count so that you know at what frequency to pop the element. When a number is
added to the stack, increment its count in the dictionary, append it to the count in the frequency default dict and update the max frequency accordingly
3. Pseudo Code:
    1. Initialise a max frequency count, a default dict of lists that appends to it elements of that particular count and a dictionary that keeps track of each elements count
    2. Add the new items into the frequency dictionary and increment its count. Update the max frequency if needed
    3. When popping, use the max frequency count to search for the element in the frequency default dictionary. Pop and return that element. If the array for that count is now empty, decrement the maximum frequency count
4. Time Complexity: O(1)
5. Space Complexity: O(n)
6. Learnings: Have a max frequency count to keep track of counts and make searches O(1)



Asteroid Collision

1. Edge Case: all left moving asteroids, all right moving asteroids
2. Idea: Have a stack to keep track of the asteroids already seen. A collision only happens when a right asteroid is before a left asteroid
3. Pseudo Code:
    - Initialise the stack with the first asteroid
    - While the subsequent asteriods are left asteriods, check if the top of the stack is a right asteriod, if it is, collide both of them. If their values sre the same, break out of the loop and dont execute the else block. If they have deltas, obtain the delta use it to continue colliding with the rest if the other right moving asteroids
    - Have a while else else block to append the asteroid back to the array once the while loop is exited
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: While else block where the else block will be executed when the loop terminates unless a break statement is present


Basic Calculator 2

1. Edge Case: Invalid expressions, zeros, negative numbers, 
2. Idea: Since * and / take precedence, do those expressions first while appending the rest to the stack. For negative numbers, simply append -num is enough as afterward, just return the sum of the stack
3. Pseudo Code: 
    1. Initialise a stack, a num variable, and a sign variable
    2. Iterate through the string
        - If the character is a digit, multiply the current digit by 10 and then add the new digit, this is the new num
        - If the character is one of the signs or the last digit has been reached:
            - If the current sign is +, append num to the array and save the new sign
            - If the current sign is -, append -num to the array and save the new sign
            - If the current sign is *, pop the stack and multiply the popped value with num. Append this new value to the stack and save the new sign
            - If the current sign is /, pop the stack and divide the popped value with num. Append this new value to the stack and save the new sign
    3. Return the sum of the stack
4. Time Complexity: O(n) - Each value is inserted and popped from the stack at most once each 
5. Space Complexity: O(n)
6. Learnings: Save the previous sign as a variable and only perform the operation if there is a new sign or we've reached the last digit. Also remember to convert the characters to ints to do the operations


Car Fleet 

1. Edge Case: Entire array is one fleet, each car is its own fleet
2. Idea: Sort the array by starting position and calculate where it would end up after x amount of time. Iterate the array in descending order and for each car that reaches a lesser distance, create a new fleet
3. Pseudo Code: 
    1. Zip the position and speed together and sort the array by starting position
    2. Iterate the array from the back, and for each car, find the destination reached after x amount of time. Save this as a variable
    3. If the next car reaches or exceeds this variable destination, it joins the previous car as one fleet, else, it is its own new fleet
    4. Count and return the total number of fleets
4. Time Complexity: O(nlogn)
5. Space Complexity: O(n)
6. Learnings: Zip and sort array, each car that reaches a lesser destination point creates a new fleet


Daily Temperatures

1. Edge Case: Temperatures are all non-increasing, temperatures are always increasing
2. Idea: Create a monoatomically non-increasing stack where elements are popped and process if there is an element that is greater than it
3. Pseudo Code: 
    1. Initialise a stack and a result array with default values of -1
    2. While the stack is non null and the current value is more than the head of the stack
        - Pop the head of the stack and subtract its index with the current value's index, append this at the index in the results array
    3. Append the index of the current element to the stack 
    4. Return the result array
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Using monoatomically non-increasing stack, be sure the check that the stack is non null


Decode string

1. Edge Case: invalid input string, non-bracket and non-numeric characters, negative integers?, decimal numbers?, 0s?
2. Idea: Initialise a stack, num and res. Add to num or add to res until an open bracket is reached, then append num and res to the stack and reset it. Repeat inside the the bracket. When met with a closing bracket or the end of the string is reached, multiply res with the popped out num and append it to the popped
out res string, continue until the and of the string
3. Pseudo Code:     
    1. Initialise a stack, num and res. Iterate through the string
        - If the character is a number, multiply the current number by 10 and add to it, forming the new number. 
        - If the character is a string, append to the end of res
        - If the character is an open bracket, save the num and res into the stack and reset them
        - If the character is a closed bracket or the last character, pop num and res from the stack. Multiply the current res with num and then let the new res += res in the bracket
    2. Return res
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Have the stack remember the previous multiplier and res before the brackets, let the res save the current string up to that point


Evaluate Reverse Polish Notation

1. Edge Case: division or multipliation by zero, divison or multipliation by negative numbers, decimal numbers, invalid notation (pop from stack when stack is empty)
2. Idea: Have a stack to store the numbers, for each operand, pop the number and do the operation, append back the result into the stack
3. Pseudo Code: 
    1. Initialise the stack 
    2. Iterate through the string and append to the stack if its a digit. Make sure that it is converted to integers before appending
    3. If the character is any of the operands, pop and perform the operation. Make sure the stack is not empty
    4. Take note for division, convert number to int so as to not deal with decimal places


Generate Parenthesis

1. Edge Case: n = 0 
2. Idea: sort of like backtracking where at each case it can branch out into two cases
    1. if the number of ( is less than n, then add a (
    2. if the number of ) is less than n, then add a )
3. Pseudo Code
    1. Initialise a dfs function taking in x and y which are the number of open and close brackets
    - if x + y == n: append the copy of the current string into the result array
    - if x < n: append a open bracket into the string
    - if x < y: append a close bracket into the string
    2. Return the res array
4. Time Complexity: O(2^n)
5. Space Complexity: O(n) as only that stack is used
6. Learnings: Backtracking


Min stack

1. Edge Case: negative numbers
2. Idea: Have the stack save the current number as well as the minimum number. Save the minimum number by comparing the current number with the previous minimum number
3. Pseudo Code: 
    1. Initialise a stack
    2. For each element, save the number as well as the minimum number
        - If the current number is smaller than the minimum number, save the current number
        - If the current number is more, save the previous minimum number
    3. For pops, return the minimum number
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Save the minimum number as the second element of the tuple to save both space complexity and time complexity in retrieval


Online Stock Span

1. Edge Case: Continuously increasing prices, Continuously decreasing prices
2. Idea: Create a monoatomically decreasing stack that saves but the current price and its number of stocks that it is greater than. If the current number is greater than the top of the stack, pop from the stack and increment the current element's count
by the count of that particular element. Once the while loop terminates, add this item to the stack
3. Pseudo Code:
    1. Initialise an array
    2. Iterate through the list and if the current price is more than the previous price, pop the previous prices and increment the count
    3. Append the current price and its count to the stack
    4. Return the count
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Check if stack is non-empty, increment the count based on the previous counts
7. Example: 
[[], [100], [80], [60], [70], [60], [75], [85]]
stack = [[100, 1], [85, 6]]
res = [1, 1, 1, 2, 1, 4, 6]


Remove duplicate letters

1. Edge Case: string of all the same letters
2. Idea: Create a dictionary that stores all the last indexes of the letters, do this by iterating through and overriding the index of each character until the end of the string is reached. Loop through the array and construct the lexicographic string
by checking first whether the letter is in the monoatomically increasing stack and if the letter can be popped out (the last index is still down the road)
3. Pseudo Code:
    1. Initialise a dictionary of all the last indexes of the elements
    2. Initialise a lexicographically increasing stack and a set to track what elements are in the stack
    3. For each new element
        - If the element is already in the stack, continue
        - If the element is lexicographic greater than the top of the stack, append it to the stack
        - Else, check if the top of the stack has a end index greater than the current index, if yes then pop from the stack and remove it from the set, else, still append to the stack
    4. Returned the joined version of the stack
4. Time complexity: O(n)
5. Space complexity: O(n)
6. Learnings: Check of whether the index is the last index such that a better lexicographically small answer can be found


Simplify Path

1. Edge Case: Invalid path structure
2. Idea: Have a stack to keep track of the path
3. Pseudo Code:
    1. Split the current path via the '/'. 
    2. Loop through the various elements of the split text
        - If it is a string, append to the res
        - If it is a .., pop from the res if the res is non-empty
    3. Join back the array with '/', and add a '/' at the front of the string
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Split array by '/' and remember to join it back
        

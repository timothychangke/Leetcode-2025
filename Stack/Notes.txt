Baseball Game

1. Edge Case: Invalid inputs, negative numbers, 
2. Pseudo Code: 
    1. Initialise a stack
    2. Iterate through the operations string and check for the various characters
        - If character is 'C': pop the top of the stack
        - If the character is 'D': pop, multiply by two and append back the top of the stack
        - If the character is '+': pop the two most recent elements from the stack, add them up and append them back into the stack
        - Else, append that character into the stack
3. Time Complexity: O(n)
4. Space Complexity: O(n)


Implement Queue using a stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have two stacks, stack 1 and stack 2. When you append things append it to stack 1. When you pop things, first check if stack 2 is empty, if it is not, then pop from stack 2. Else, move over all the items from stack 1 to stack 2, this inverts
the order of all the elements
3. Pseudo Code: 
    1. Initialise two stacks
    2. For appends, add it to the first stack
    3. For pops, 
        - If stack 2 is not empty, pop from stack 2
        - Else, while stack 1 is not empty, pop then append all elements into stack 2, then pop the very last element
    4. For peeks, do the pop operation just that you return and not pop the last element
4. Time Complexity: O(1) for appends and O(1) also for pops. Each element is popped only once 
5. Space Complexity: O(n)


Implement Queue using stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have a queue where you append to the end of the queue, but when it is time to pop, you pop and append n - 1 elements such that the lru element is now at the top of the queue
3. Pseudo Code:
    1. Initialise a queue
    2. For appends, add to the back of the queue
    3. For pops, pop and reappend n - 1 elements in the queue such that the most recently added element is at the top of the queue
    4. For peek, just return the last element in the queue
4. Time Complexity: O(1) for appends and O(n) for pops
5. Space Complexity: O(n)


Valid Parenthesis

1. Edge Case: Parenthesis pattern is contains characters that are not brackets
2. Idea: Initialise a stack mapping closing brackets with their openning brackets. Have a stack to store open brackets. When met with a closing bracket, pop from the stack and check if its the corresponding open bracket. If invalid, return false
3. Pseudo Code:
    1. Initialise a hash map with the closing brackets as the keys and the openning brackets as the values. 
    2. Iterate through the string
        - If the element is a not in the dictionary (an openning bracket), append it to the stack
        - Else, pop the stack and check if the current element (a closing bracket) correspondes to the openning bracket, if not return false
    3. Return True but only if the stack is empty
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Check for any elements left in the stack as well to ensure validity


Largest Rectangle in Histogram

1. Edge Case: all increasing or all decreasing height arrays
2. Idea: Declare a monoatomically increasing stack as the height of the rectangle only stops growing if there is a rectangle smaller than it. 
3. Pseudo Code:
    1. Append a zero at the end of the height array to clear all the rectangles still left in the stack
    2. Initialise a monoatomically increasing stack that pops elements if they are more than the current one (append their index). After the pop, calculate the area generated by that rectangle and append to res if its greater
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Initalising of the 0 at the end to clear all the remaining rectangles as well as appending a -1 to the stack so that the first rectangles area can be calculated


Maximum Frequency stack

1. Edge Case: 
2. Idea: Initialise a default dict that stores the frequencies of the elements and the dictionary that stores the counts. Also initialise a max count so that you know at what frequency to pop the element. When a number is
added to the stack, increment its count in the dictionary, append it to the count in the frequency default dict and update the max frequency accordingly
3. Pseudo Code:
    1. Initialise a max frequency count, a default dict of lists that appends to it elements of that particular count and a dictionary that keeps track of each elements count
    2. Add the new items into the frequency dictionary and increment its count. Update the max frequency if needed
    3. When popping, use the max frequency count to search for the element in the frequency default dictionary. Pop and return that element. If the array for that count is now empty, decrement the maximum frequency count
4. Time Complexity: O(1)
5. Space Complexity: O(n)
6. Learnings: Have a max frequency count to keep track of counts and make searches O(1)



Asteroid Collision

1. Edge Case: all left moving asteroids, all right moving asteroids
2. Idea: Have a stack to keep track of the asteroids already seen. A collision only happens when a right asteroid is before a left asteroid
3. Pseudo Code:
    - Initialise the stack with the first asteroid
    - While the subsequent asteriods are left asteriods, check if the top of the stack is a right asteriod, if it is, collide both of them. If their values sre the same, break out of the loop and dont execute the else block. If they have deltas, obtain the delta use it to continue colliding with the rest if the other right moving asteroids
    - Have a while else else block to append the asteroid back to the array once the while loop is exited
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: While else block where the else block will be executed when the loop terminates unless a break statement is present


Basic Calculator 2

1. Edge Case: Invalid expressions, zeros, negative numbers, 
2. Idea: Since * and / take precedence, do those expressions first while appending the rest to the stack. For negative numbers, simply append -num is enough as afterward, just return the sum of the stack
3. Pseudo Code: 
    1. Initialise a stack, a num variable, and a sign variable
    2. Iterate through the string
        - If the character is a digit, multiply the current digit by 10 and then add the new digit, this is the new num
        - If the character is one of the signs or the last digit has been reached:
            - If the current sign is +, append num to the array and save the new sign
            - If the current sign is -, append -num to the array and save the new sign
            - If the current sign is *, pop the stack and multiply the popped value with num. Append this new value to the stack and save the new sign
            - If the current sign is /, pop the stack and divide the popped value with num. Append this new value to the stack and save the new sign
    3. Return the sum of the stack
4. Time Complexity: O(n) - Each value is inserted and popped from the stack at most once each 
5. Space Complexity: O(n)
6. Learnings: Save the previous sign as a variable and only perform the operation if there is a new sign or we've reached the last digit. Also remember to convert the characters to ints to do the operations


Generate Parenthesis

1. Edge Case: 
2. Idea: sort of like backtracking where at each case it can branch out into two cases
    1. if the number of ( is less than n, then add a (
    2. if the number of ) is less than n, then add a )
3. Pseudo Code
Initialise a dfs function taking in x and y which are the number of open and close brackets
if x + y == n: append the copy of the current string into the result array
if x < n: append a open bracket into the string
if x < y: append a close bracket into the string
return the res array
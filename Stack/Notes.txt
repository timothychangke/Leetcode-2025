Baseball Game

1. Edge Case: Invalid inputs, negative numbers, 
2. Pseudo Code: 
    1. Initialise a stack
    2. Iterate through the operations string and check for the various characters
        - If character is 'C': pop the top of the stack
        - If the character is 'D': pop, multiply by two and append back the top of the stack
        - If the character is '+': pop the two most recent elements from the stack, add them up and append them back into the stack
        - Else, append that character into the stack
3. Time Complexity: O(n)
4. Space Complexity: O(n)


Implement Queue using a stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have two stacks, stack 1 and stack 2. When you append things append it to stack 1. When you pop things, first check if stack 2 is empty, if it is not, then pop from stack 2. Else, move over all the items from stack 1 to stack 2, this inverts
the order of all the elements
3. Pseudo Code: 
    1. Initialise two stacks
    2. For appends, add it to the first stack
    3. For pops, 
        - If stack 2 is not empty, pop from stack 2
        - Else, while stack 1 is not empty, pop then append all elements into stack 2, then pop the very last element
    4. For peeks, do the pop operation just that you return and not pop the last element
4. Time Complexity: O(1) for appends and O(1) also for pops. Each element is popped only once 
5. Space Complexity: O(n)


Implement Queue using stack

1. Edge Case: Invalid calls -> ie popping when empty
2. Idea: Have a queue where you append to the end of the queue, but when it is time to pop, you pop and append n - 1 elements such that the lru element is now at the top of the queue
3. Pseudo Code:
    1. Initialise a queue
    2. For appends, add to the back of the queue
    3. For pops, pop and reappend n - 1 elements in the queue such that the most recently added element is at the top of the queue
    4. For peek, just return the last element in the queue
4. Time Complexity: O(1) for appends and O(n) for pops
5. Space Complexity: O(n)


Valid Parenthesis

1. Edge Case: Parenthesis pattern is contains characters that are not brackets
2. Idea: Initialise a stack mapping closing brackets with their openning brackets. Have a stack to store open brackets. When met with a closing bracket, pop from the stack and check if its the corresponding open bracket. If invalid, return false
3. Pseudo Code:
    1. Initialise a hash map with the closing brackets as the keys and the openning brackets as the values. 
    2. Iterate through the string
        - If the element is a not in the dictionary (an openning bracket), append it to the stack
        - Else, pop the stack and check if the current element (a closing bracket) correspondes to the openning bracket, if not return false
    3. Return True but only if the stack is empty
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Check for any elements left in the stack as well to ensure validity


Generate Parenthesis

1. Edge Case: 
2. Idea: sort of like backtracking where at each case it can branch out into two cases
    1. if the number of ( is less than n, then add a (
    2. if the number of ) is less than n, then add a )
3. Pseudo Code
Initialise a dfs function taking in x and y which are the number of open and close brackets
if x + y == n: append the copy of the current string into the result array
if x < n: append a open bracket into the string
if x < y: append a close bracket into the string
return the res array
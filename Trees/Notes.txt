Balanced Binary Tree

1. Edge Case: Empty tree, tree with only one node
2. Idea: Traverse the tree and return False if the difference in depths between a left and right node differs by more than one, else, return the max of left and right as that is the depth for that node
3. Pseudo Code:
    1. Define a dfs function
        - Terminal condition: if null, return 0
        - Perform dfs for left and right node
        - If the difference between the left and right node is greater than 1, or that left or right is already a -1,  return -1
        - Else, return the max of left and right + 1
    2. Return the result of the check of whether dfs == -1
4. Time Complexity: O(n) where n is the number of nodes
5. Space Complexity: O(1)
6. Learnings: Have the dfs return -1 and propagate this -1 to the top of the call stack


Binary Tree Preorder Recursive Traversal

1. Edge Case: Null or single node tree
2. Pseudo Code:
    1. Initialise a dfs function
    - Terminal condition: if null, return 
    - Performs function (ie print)
    - dfs(left)
    - dfs(right)
3. Time Complexity: O(n)
4. Space Complexity: O(1)


Binary Tree Inorder Recursive Traversal

1. Edge Case: Null or single node tree
2. Pseudo Code:
    1. Initialise a dfs function
    - Terminal condition: if null, return 
    - dfs(left)
    - Performs function (ie print)
    - dfs(right)
3. Time Complexity: O(n)
4. Space Complexity: O(1)


Binary Tree Postorder Recursive Traversal

1. Edge Case: Null or single node tree
2. Pseudo Code:
    1. Initialise a dfs function
    - Terminal condition: if null, return 
    - dfs(left)
    - dfs(right)
    - Performs function (ie print)
3. Time Complexity: O(n)
4. Space Complexity: O(1)


Binary Tree Preorder Iterative Traversal

1. Edge Case: Null or single node tree
2. Idea: Use a stack to keep track of the right nodes after traversing to and processing the left nodes. Until null, pop a node from the stack, process and start back up at the start of the loop
3. Pseudo Code:
    1. Initialise a stack and curr to be the root node
    2. While stack or curr
        - If curr
            - append curr to res
            - append curr.right to the stack
            - let cur be cur.left
        3. Pop from the stack and let curr = stack.pop()
        4. Move back to the top of the stack
4. Time Complexity: O(n)
5. Space Complexity: O(n) for the stack
6. Learnings: If condition to check if curr is null, if it is, let curr = stack.pop() which is the most recent right nodes


Binary Tree Inorder Iterative Traversal

1. Edge Case: Null or single node tree
2. Idea: Use a stack to keep track of all previous cur.left nodes. Keep moving left and appending the node to the stack. Until cur is null, pop from the stack, save it to the result then set cur to be cur.right
3. Pseudo Code:
    1. Initialise a stack and curr to be the root node
    2. While stack or curr
        - While curr 
            - Append curr to the stack 
            - Set curr to be curr.left
        - Pop from the stack and append the node to the res
        - Set cur to be cur.right
4. Time Complexity: O(n)
5. Space Complexity: O(n) for the stack
6. Learnings: Append the cur.left until its null, the pop and traverse to the right by one


Binary Tree Postorder Iterative Traversal

1. Edge Case: Null or single node tree
2. Idea: A node is processed if it has been touched twice. Append to the stack the node and whether it has been touched twice, process the node if it has been touched twice
3. Pseudo Code:
    1. Initialise a stack with the initial value of (root, false)
    2. While stack
        3. Pop from the stack and if true, append to res
        4. Else, if node is non-null, append to the stack (root, True) and root.left and root.right with values of false
4. Time Complexity: O(n)
5. Space Complexity: O(n) for the stack
6. Learnings: Post order processes nodes if touched twice


Diameter of binary tree

1. Edge Case: Null or single node tree, linked list tree
2. Idea: Perform dfs which sets res to the current diameter, then returns the max value of the depth of its left and right trees
3. Pseudo Code:
    Initialise a dfs function 
    1. Terminal condition: if null, return 0
    2. Obtain dfs for node.left
    3. Obtain dfs for node.right
    4. Calculate diameter and set to res if needed
    5. Return the max of left and right as that is the max depth and hence the left/right portion of the diameter plus one (including the current node)
4. Time Complexity: O(n) for the number of nodes
5. Space Complexity: O(1)
6. Learings: Compute res but return the max depth of that particular node. The max diameter does not necessarily pass through the root


Invert Binary Tree

1. Edge Case: Null or single node tree
2. Idea: Recursively go down the tree and swap the left and right nodes
3. Pseudo Code:
    1. If null, return 
    2. set the left and right nodes to be the func(right) and func(left) nodes
    3. return the root
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: No need to initialise a dfs function


Maximum depth of binary tree

1. Edge Case: Null or singlely depthed node tree
2. Idea: Recursively return the max depth of the left and right tree
3. Pseudo Code
    1. if null, return 0
    2. return max(dfs(left), dfs(right)) + 1
    3. Call the function for the root node
4. Time Complexity: O(n)
5. Space Complexity: O(1)
Learnings: No need for a dfs function, can just call the exisiting function. Could also use a bfs to count the max depth


Same Tree

1. Edge Case: Null or singlely depthed node tree
2. Idea: Check if the both children are null, these means that the entire tree has been traversed and both trees are valid, else return False, return the dfs values of the left and right subtrees
3. Pseudo Code:
    1. If both subtrees are null, return True
    2. If only one of them are null or their vaules are not equal, return false
    3. Return the dfs value of the left subtree and the dfs value of the right subtree as both have to be true
4. Time Complexity: O(n)
5. Space Complexity: O(1)
Learnings: If both subtrees reach the null stage and did not return false, then they are valid trees




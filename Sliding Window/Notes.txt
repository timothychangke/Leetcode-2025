Best Time to Buy and Sell Stock

1. Edge Case: non-increasing array
2. Idea: Implement a sliding window that restarts when the right pointer is less than the left pointer
3. Pseduo Code: 
    1.Initialise the left pointer and have a for loop that moves the right pointer
    2. When the value of the right pointer is more than that of the left pointer, record this value to the res
    3. Else, let the left pointer = right pointer
4. Time Complexity: O(n)
5. Space Complexity: O(1)
6. Learnings: No need to iterate through every possiblility if the delta between the left and right pointer is negative


Contains duplicate 2
1. Edge Case: k is less than zero
2. Idea: have a sliding window of size k where all elements in the window are distinct, else return false
3. Pseudo Code: 
    1. Have a for loop to represent the right pointer and a set to save the elements in the window
    2. At each loop, check if the new element is already in the set
    3. r - l >= k, increment l by 1 and remove the element from the set
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Code is simplier if there is just a check whether r - l >= k as a condition to increment l


Minimum Window Substring

1. Edge Case: String s does not contain the substring of t, lowercase and uppercase letters
2. Idea: Initialise a have map and a need map, as well as a have counter and a need counter to reduce looping through the dictionary. For each letter in s, check if the letter is needed in t. Once all the conditions of t are met, 
move the left pointer so see if the condition can still be fulfilled with a smaller string length. Repeat until the condition is no longer true and save each length to res
3. Pseudo Code  
    1. Initialise a have map and a need map, with the need map being a counter of t and the have map being empty. Also initialise a have count and a need count where the need count is the length of the need map
    2. Iterate through the string s, checking if the letter is present in the need map, if it is, increment the have map by one
    3. If the count in the have map is equal to the count in the need map, increment the have counter by one
    4. While the have counter == need counter, save the length to res and move the left pointer by one and remove the left pointer's letter from the have map. If the count in the have map is now not greater than or equal to that of the need map, break out fo the loop
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Using a count to check if they are the same will reduce the need to compare both dictionaries


Sliding window maximum

1. Edge Case: Negative numbers, numbers with the same value
2. Idea: Create a monoatomically decreasing stack, at each window, we only care about the maximum values and the values after the maximum value after it has be passed, values preceding that are smaller are no longer relevant.
3. Pseudo Code: 
    1. Have a for loop that represents the right pointer go through the array, and let the left pointer be zero. Also initialise a res array to store the results as well as monoatomically non-increasing stack that saves the index of the numbers
    2. For each element that is looped across, add it to the monoatomically non-decreasing stack
    3. If the top of the stack's index is less than the current left pointer, popleft the array
    4. If r - l >= k, append the top of the stack to res 
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Use a monoatomically non-increasing stack to store the numbers. Popped off numbers are not relevant to us
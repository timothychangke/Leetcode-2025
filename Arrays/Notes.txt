Add to Array-Form of Integer

1. Edge Cases: Adding from an empty array, adding zeros, handling carry overs
2. Pseudo code:
    1. Initialise a carry value, a result value, a pointer that traverses the array backwards
    2. While the pointer is greater than zero or sum or carry:
        - Sum the all the elements together and mod them by 10, obtain the carry by doing floor division by 10
        - Add this value to the res by multiplying it with 10 * pow
        - Decrement the pointer, divide the number by 10 and increment the pow
        - If the num is 0, have it return 0 in the sum. if the index is <= 0, have it return zero in the sum (handling of overflow)
    3. Return res
3. Time Complexity: O(n + m)
4. Learnings:
- Use the pow method to append to the front of a number
- Use floor division to obtain the carry


Best Time to Buy and Sell Stock

1. Edge Cases: empty array?, one element array?, two element array with non-increasing values?
2. Pseudo Code:
    1. Initialise the left and right pointers and a res variable
    2. While the right pointer does not exceed the length of the array:
        - if the value at the right pointer is more than the value at the left, save it to res if it is greater than res
        - else, let left = right 
        - increment right by one
    3. Return res
3. Time Complexity: O(n)
4. Learnings:
 - Reset sliding window when the delta is no longer positive


Concatenation of Array

1. Edge Cases: empty array
2. Pseudo Code:
    1. Return the array multiplied by two
3. Time Complexity: O(n)


Contains Duplicates

1. Edge Cases: empty array?, all duplicates, no duplicates
2. Pseudo Code:
    1. Turn both arrays into sets and compare the lengths of both sets
    2. Return if the length of the sets are the same
3. Time Complexity: O(n)


Count Binary Strings

1. Edge Cases: empty string, one element string, invalid string?
2. Idea:
Comparing two sections of the string (either a 1s section and a 0s section or a 0s section and a 1s section), finding the minimum length between these two sections will return the number of substrings grouped consecutively within that two sections
3. Pseudo Code
    1. Pre compute the length of each consecutive section of zeros or ones
    2. For each pair of sections side by side, calculate the minimum value between these two sections. This would return the number of substrings that are grouped consecutively between these two sections
    3. Increment the res for each of these sections and return the final value
4. Time Complexity: O(n)


Degree of an Array

1. Edge Cases: empty string, elements with multiple max frequency
2. Idea:
To solve this in one pass, there are several steps to do 
- Save the index of the first occurrence of the element. 
- Save the max frequency of each element. If the max frequency is greater then the current max, the res is the length of the current index and the element's first index
- If the count of the current element is the same as the max frequency and its starting index is ahead of the current max frequency's starting index, meaning that its substring length is shorter, save it as the res instead
3. Pseudo Code:
    1. Initialise a res, a dictionary to store the max frequencies, a dictionary to store the first index, and a max frequency variable
    2. Iterate through the string
        - If not in the first index map, add the index inside
        - Increment the max frequency of the element. If it greater than the current max frequency, save its substring length as the res. This is calculated by minusing the current index position with the first index position   
        - If the current frequency is equal to that of the current max frequency and its length is shorter than the current res, save this length as res
    3. Return res
4. Time Complexity: O(n)
5. Space Complexity: O(n)
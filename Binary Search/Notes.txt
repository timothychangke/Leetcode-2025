Binary Search

1. Edge Case: Element does not exist in array, array contains non-numeric characters?
2. Pseudo Code: 
    1. Initialise a left and right pointer at both ends of the sorted array. 
    2. Find the middle element. 
         - if it is larger than the target, it means that the element in question is in the left half of the array
         - else it is in the right half
    3. If the element is found, return the index of the element
    4. Repeat the loop until the element is found
3. Time Complexity: O(nlogn)
4. Space Complexity: O(1)


First Bad Version

1. Edge Case: The first bad version is the first/last element in the array
2. Pseudo Code:
    1. Initialise a left and right pointer for both ends of the array
    2. Find the middle element and while the left is less than or equal to the right
        - If the elmenet is a bad version, save it to the array and move leftward to find the smaller bad version
        - If the element is not a bad version, move rightward to find the bad version
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: This is the common pattern of binary search, where if the condition is met, you move leftward to find the smaller result
that still meets the condition. If the condition has yet to be met, you move rightward to find a result that meets the condition. 
Whether or not the ternary condition is l < r or l <= r is determined by if the left and right pointers can overlap or not


Guess Number Higher or lower

1. Edge Case: Pick > n?
2. Pseudo Code:
    1. Initialise a left and right pointer for both ends of the array
    2. Find the middle point and while left is less than or equal to right
        - If the element is equal to pick, return pick
        - If the element is more than pick, move the right pointer mid - 1
        - If the element is less than pick, move the left pointer to mid + 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)


Search Insert Position

1. Edge Case: Index is inserted at the start of the array, Index is inserted at the end of the array
2. Pseudo Code:
    1. Initialise the left boundary to be 0 and right boundary. Initialise the res variable to be the len(nums), so as to account for 
    the scenario where 
    2. Find the middle point and while left is less than or equal to right
        - If the element is equal to the target, return the element
        - If the element is less than the target, move the left pointer mid + 1
        - If the element is more than the target, save the index to res and move the right pointer to mid - 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: Initialise the res to be the index after the end of the string so as to account for the edge case where the all elements
is less than the target


Sqrt(x)

1. Edge Case: x = 0, x = 1
2. Pseudo Code:
    1. Initialise the left pointer to be 0 and the right pointer to be x. These are the boundaries where the square root of the value will lie in
    2. While left <= right, find the mid point
        - If the mid point squared is less than or equal to x, save the value to res and shift the left pointer to mid + 1
        - Else, shift the right pointer to mid - 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: Though it doesn't look like this question can be solved via binary search, it can



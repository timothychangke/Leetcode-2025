Binary Search

1. Edge Case: Element does not exist in array, array contains non-numeric characters?
2. Pseudo Code: 
    1. Initialise a left and right pointer at both ends of the sorted array. 
    2. Find the middle element. 
         - if it is larger than the target, it means that the element in question is in the left half of the array
         - else it is in the right half
    3. If the element is found, return the index of the element
    4. Repeat the loop until the element is found
3. Time Complexity: O(nlogn)
4. Space Complexity: O(1)


First Bad Version

1. Edge Case: The first bad version is the first/last element in the array
2. Pseudo Code:
    1. Initialise a left and right pointer for both ends of the array
    2. Find the middle element and while the left is less than or equal to the right
        - If the elmenet is a bad version, save it to the array and move leftward to find the smaller bad version
        - If the element is not a bad version, move rightward to find the bad version
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: This is the common pattern of binary search, where if the condition is met, you move leftward to find the smaller result
that still meets the condition. If the condition has yet to be met, you move rightward to find a result that meets the condition. 
Whether or not the ternary condition is l < r or l <= r is determined by if the left and right pointers can overlap or not


Guess Number Higher or lower

1. Edge Case: Pick > n?
2. Pseudo Code:
    1. Initialise a left and right pointer for both ends of the array
    2. Find the middle point and while left is less than or equal to right
        - If the element is equal to pick, return pick
        - If the element is more than pick, move the right pointer mid - 1
        - If the element is less than pick, move the left pointer to mid + 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)


Search Insert Position

1. Edge Case: Index is inserted at the start of the array, Index is inserted at the end of the array
2. Pseudo Code:
    1. Initialise the left boundary to be 0 and right boundary. Initialise the res variable to be the len(nums), so as to account for 
    the scenario where 
    2. Find the middle point and while left is less than or equal to right
        - If the element is equal to the target, return the element
        - If the element is less than the target, move the left pointer mid + 1
        - If the element is more than the target, save the index to res and move the right pointer to mid - 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: Initialise the res to be the index after the end of the string so as to account for the edge case where the all elements
is less than the target


Sqrt(x)

1. Edge Case: x = 0, x = 1
2. Pseudo Code:
    1. Initialise the left pointer to be 0 and the right pointer to be x. These are the boundaries where the square root of the value will lie in
    2. While left <= right, find the mid point
        - If the mid point squared is less than or equal to x, save the value to res and shift the left pointer to mid + 1
        - Else, shift the right pointer to mid - 1
3. Time Complexity: O(logn)
4. Space Complexity: O(1)
5. Learnings: Though it doesn't look like this question can be solved via binary search, it can


Find in Mountain Array

1. Edge Cases
2. Idea: Find the peak of the mountain array, then perform binary search on the ascending portion of the mountain array and binary search on the descending portion of the mountain array. One optimisation is to  also try to find the element while
finding the peak of the mountain
3. Pseudo Code:
    1. While left <= right, find the smallest point where i > i + 1
        - If that is the case, save it to res and let r = mid - 1
        - Else move l = mid + 1
        - Do the additional check of if num == target, then return it
    2. Check the ascending portion of the array, so perform binary search up to peak to find the target
    3. If still not present, check the descending portion of the array by performing binary search on the descending portion of the mountain array
    4. If still not found, return -1 
4. Time Complexity: O(3logn) = O(logn)
5. Space Complexity: O(1)
6. Learnings: Have an optimisation to also search for the target while searching for the peak


Median of Sorted Array

1. Edge Case: Median is in one of the arrays, Median spans across both arrays, Median is a single number, Median is the middle of two numbers
2. Idea: Perform Binary search to find the index of the median on the arr1. The condition is that the arr1 index is smaller than the arr2 index, while the arr2 index is smaller than the arr1 index + 1. If that is the case, then return the small of
two indexes (arr2 index + 1 and arr1 index + 1), else find the max between the two indexes for both index and index + 1 and return the average between the two. Also there are many edge cases to take care off regarding the value of these four values, 
especially when they are at the boundaries of the arrays
3. Pseudo Code:
    1. Have the length of arr1 be the array with the shorter length
    2. Initialise the left and right pointers at the two ends of array 1
    3. While True: 
        - Let i be the mid point between l and r, then derive j based on the total length of the two arrays
        - Caculate a1, a2, b1, b2 based on i and j. In the event that they are out of range of the array, set them to either inf or -inf so that they satisfy the condtion check
        - If a1 <= b2 and b1 <= a2, the median has been found
            - Based on whether the total length of the arrays are divisible by 2, return either the min of a2 and b2 or the mid point of max(a1, b1) and min(a2, b2)
        - Else, 
            - If a1 > b2, shift r to mid - 1
            - Else, shift l to mid + 1
4. Time Complexity: O(logn)
5. Space Complexity: O(1)
6. Learnings: Swapping of arguments to get the smallest array be array 1, simplifying the problem to be the finding of the boundary between a1, a2, b1, and b2, satisfy the various edge cases by setting a1, a2, b1, b2 to always meet the conditions when
they are out of bounds
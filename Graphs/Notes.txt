Find the Town Judge

1. Edge Case: There is no town judge
2. Idea: For each trust connection, increment the second element. And decrement the trustee as the judge cannot trust others. Then check if there is an element with n - 1 elements
3. Pseudo Code:
    1. Initialise a arry of n 0s
    2. For each tuple in the trust array, decrement the truster and increment the trustee'
    3. Loop through the array and if there is an element that has a count of n - 1, return true, else return false
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Solve with simple counting and not graphs


Island Perimeter

1. Edge Case: The island covers the entire grid, No island
2. Idea: Traverse to each square that is a 1, if there is an adjacent square that is water of the boundary, this mean that edge part of the Perimeter
3. Pseudo Code:
    1. Define a dfs function that takes in the row and the column
    2. If the r or c are not valid and the grid[r][c] is 0, return 1
    3. If grid[r][c] is an island, turn it to -1 so that it does not get traversed again. Return dfs on the four adjacent squares, else return 0
    4. Increment res when doing dfs for each island that it comes across and return res
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Mark the island as seen by setting it to -1, if r, c are invalid or water, it is a perimeter to return 1


Making a Large Island

1. Edge Case: No islands
2. Idea: Create a hash map with the key being the island counter and the size of the island being the value. Count each islands size and save it to the dictionary. Also set the counter for each 
of its islands. Go through the table once more and for each index, check its adjacent index and calculate its max res based on the islands it touches. Save it in a set so that the same island is
not counted twice. 
3. Pseudo Code:
    1. Define a dfs function that returns the size of each island and sets all elements in the island to be the value of the counter. Increment this counter by 1 each time
    2. Save these values into a hash map
    3. Go thorugh the grid once more and check the adjacent squares. If they are valid and not 0, create a set of these indexes. Calculate the size to the sum of these indexed islands plus the
    added island
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Set the initial counter value to be 2 so that it doesnt confuse it with the other islands. Set the initial res to be the maximum original island. Set the 0 to be 0 in the hash map for 
waters


Shortest distance from all buildings

1. Edge Case: No buildings, one building, all obstacles, 
2. Idea: For each building, do a bfs to mark the distance at each point a new grid. set the point to the empty variable, which is decremented and tracked each time to make sure that it is visitable 
from every building. set the value by the depth and push it back into the queue with the new depth. Keep track of a local min as well and set this local min to res so that another loop is not needed
3. Pseudo Code:
    1. Initialise a new grid, set the empty value and decrement it every iteration, initialise a local min
    2. Traverse each cell and check if the value is a building, if it is, perform bfs
    3. Create a deque with it inside, set the depth to zero. Initialise the local_min to be inf
    4. While queue, for the number of elements in the queue, popleft and traverse that cell
    5. if its value is equal to the value of empty, set it to be depth in the grid, and empty in the old grid
    6. Append it to the deque and update the local_min if appropreiate
    7. After the loop, decrement empty and update res with local_min
4. Time Complexity: O((nm)^2)
5. Space Complexity: O(nm)
6. Learnings: Local_min variable, empty variable, create a new grid to keep track of the distances


Word ladder

1. Edge Case


Redundant Connections

1. Edge Case: Multiple edges that can be removed
2. Idea: To find the edge to remove, you have to identify the edge connection two subsets that is already connected. This can be done via a union find structure, unioning values unless they are already connected
which then would return a false
3. Pseudo Code: 
    1. Initialise a union find structure
    2. Initialise a parent array containing the values of each individual element and a rank array with contains all 1s
    3. Initialise a find function: while cur not equal to par[cur], set par[cur] = par[par[cur]] for path compression and then res = par[cur]. Then return res
    4. Initialise a union find function:
        - Find the parents of a and b via find()
        - If a == b, return false
        - If the rank a of is greater, set the parent of b = a and the rank of a to += rank of b
        - If the rank of b is greater, set the parent of a = b and the rank of b to += rank of a and return True
    5. Iterate through the edges and return the result of the union
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Union find data structure for finding cycles can also be used to find the redundant edge that creates a cycle

Rotting Oranges

1. Edge Case: No Rotten Oranges, all oranges already Rotten
2. Idea: Collect all the rotten oranges and append them into the deque. Also count the number of fresh oranges. Initialise a time variable. Do a bfs starting from the rotten oranges and if the bfs ends and 
the count of fresh oranges is greater than zero, return -1, else return the time taken to rot all oranges
3. Pseudo Code: 
    1. Count the number of fresh oranges
    2. Initialise the deque with rotten oranges
    3. Initialise a counter that increments each loop
    4. While deque, for _ in range of the len of deque, popleft and traverse the neighbours of that node if it is a fresh oranges
    5. Make it rotten, decrement the count of fresh oranges and append it to the deque
    6. Return minutes if the count == 0 else -1
4. Time Complexity: O(nm)
5. Space Complexity: O(nm)
6. Learnings: Count the number of rotten oranges and decrement it each loop


Surrounding Regions

1. Edge Case: No Os, All Os, 
2. Idea: Initialise a dfs that changes Os to Ts. Perform this for all Os on the boundary. Change the remaining Os to Xs and then the Ts back to Os
3. Pseudo Code:
    1. Initialise a dfs function that sets the value to T, the traverses the neighbouring nodes and for those in range and are Os, change them to Ts
    2. Perform this dfs for the four boundaries
    3. Change the remaining Os to Xs and then the Ts back to Os
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Think of the problem inversely to no check for cells surrounded but for cells that are not surrounded. Change values to alternative temperory value


Walls and Gates

1. Edge Cases: No Gates
2. Idea: Get the r, c of each gate and create a deque with them. Do a bfs with these starting cells and set the values in each cell to be the 
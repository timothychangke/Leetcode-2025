Find the Town Judge

1. Edge Case: There is no town judge
2. Idea: For each trust connection, increment the second element. And decrement the trustee as the judge cannot trust others. Then check if there is an element with n - 1 elements
3. Pseudo Code:
    1. Initialise a arry of n 0s
    2. For each tuple in the trust array, decrement the truster and increment the trustee'
    3. Loop through the array and if there is an element that has a count of n - 1, return true, else return false
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Solve with simple counting and not graphs


Island Perimeter

1. Edge Case: The island covers the entire grid, No island
2. Idea: Traverse to each square that is a 1, if there is an adjacent square that is water of the boundary, this mean that edge part of the Perimeter
3. Pseudo Code:
    1. Define a dfs function that takes in the row and the column
    2. If the r or c are not valid and the grid[r][c] is 0, return 1
    3. If grid[r][c] is an island, turn it to -1 so that it does not get traversed again. Return dfs on the four adjacent squares, else return 0
    4. Increment res when doing dfs for each island that it comes across and return res
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Mark the island as seen by setting it to -1, if r, c are invalid or water, it is a perimeter to return 1


Making a Large Island

1. Edge Case: No islands
2. Idea: Create a hash map with the key being the island counter and the size of the island being the value. Count each islands size and save it to the dictionary. Also set the counter for each 
of its islands. Go through the table once more and for each index, check its adjacent index and calculate its max res based on the islands it touches. Save it in a set so that the same island is
not counted twice. 
3. Pseudo Code:
    1. Define a dfs function that returns the size of each island and sets all elements in the island to be the value of the counter. Increment this counter by 1 each time
    2. Save these values into a hash map
    3. Go thorugh the grid once more and check the adjacent squares. If they are valid and not 0, create a set of these indexes. Calculate the size to the sum of these indexed islands plus the
    added island
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Set the initial counter value to be 2 so that it doesnt confuse it with the other islands. Set the initial res to be the maximum original island. Set the 0 to be 0 in the hash map for 
waters
Find the Town Judge

1. Edge Case: There is no town judge
2. Idea: For each trust connection, increment the second element. And decrement the trustee as the judge cannot trust others. Then check if there is an element with n - 1 elements
3. Pseudo Code:
    1. Initialise a arry of n 0s
    2. For each tuple in the trust array, decrement the truster and increment the trustee'
    3. Loop through the array and if there is an element that has a count of n - 1, return true, else return false
4. Time Complexity: O(n)
5. Space Complexity: O(n)
6. Learnings: Solve with simple counting and not graphs


Island Perimeter

1. Edge Case: The island covers the entire grid, No island
2. Idea: Traverse to each square that is a 1, if there is an adjacent square that is water of the boundary, this mean that edge part of the Perimeter
3. Pseudo Code:
    1. Define a dfs function that takes in the row and the column
    2. If the r or c are not valid and the grid[r][c] is 0, return 1
    3. If grid[r][c] is an island, turn it to -1 so that it does not get traversed again. Return dfs on the four adjacent squares, else return 0
    4. Increment res when doing dfs for each island that it comes across and return res
4. Time Complexity: O(n^2)
5. Space Complexity: O(1)
6. Learnings: Mark the island as seen by setting it to -1, if r, c are invalid or water, it is a perimeter to return 1

s